"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.hashToParameters = hashToParameters;
exports.present = present;
exports.process_request_params = process_request_params;
exports.timestamp = void 0;
var _consts = require("./consts");
var _util = require("util");
var Crypto = _interopRequireWildcard(require("expo-crypto"));
function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
const entries = require('./entries');
const toArray = require('./toArray');
const timestamp = () => Math.floor(new Date().getTime() / 1000);
exports.timestamp = timestamp;
function present(value) {
  return value != null && ("" + value).length > 0;
}
async function sign_request(apiConfig, params, options = {}) {
  const apiKey = apiConfig.apiKey;
  const apiSecret = apiConfig.apiSecret;
  const signatureVersion = apiConfig.signatureVersion;
  params = clear_blank(params);
  if (signatureVersion === 2) {
    for (let key in params) {
      const value = params[key];
      if (Array.isArray(value)) {
        params[key] = value.map(v => typeof v === 'string' ? v.replace(/&/g, '%26') : v);
      } else if (typeof value === 'string') {
        params[key] = value.replace(/&/g, '%26');
      }
    }
  }
  params.signature = await api_sign_request(params, apiSecret);
  params.api_key = apiKey;
  return params;
}
async function api_sign_request(params_to_sign, api_secret) {
  let to_sign = entries(params_to_sign).filter(([k, v]) => present(v)).map(([k, v]) => `${k}=${toArray(v).join(",")}`).sort().join("&");
  const signature = computeHash(to_sign + api_secret, /*APIConfig().signature_algorithm || */_consts.DEFAULT_SIGNATURE_ALGORITHM, 'hex');
  return Promise.resolve(signature);
}
function clear_blank(hash) {
  let filtered_hash = {};
  entries(hash).filter(([k, v]) => present(v)).forEach(([k, v]) => {
    filtered_hash[k] = v.filter ? v.filter(x => x) : v;
  });
  return filtered_hash;
}

/**
* Computes hash from input string using specified algorithm.
* @private
* @param {string} input string which to compute hash from
* @param {string} signature_algorithm algorithm to use for computing hash
* @param {string} encoding type of encoding
* @return {string} computed hash value
*/
async function computeHash(input, signature_algorithm, encoding) {
  let hash;
  if (signature_algorithm === 'sha256') {
    const digest = await Crypto.digestStringAsync(Crypto.CryptoDigestAlgorithm.SHA256, input);
    hash = digest;
  } else if (signature_algorithm === 'sha1') {
    const digest = await Crypto.digestStringAsync(Crypto.CryptoDigestAlgorithm.SHA1, input);
    hash = digest;
  }
  return hash;
}
async function process_request_params(apiConfig, options) {
  let params = clear_blank(options);
  if (options.unsigned != null && options.unsigned) {
    params = clear_blank(options);
    //   delete params.timestamp;
    // } else if (options.oauth_token || config().oauth_token) {
    //   params = clear_blank(params);
  } else if (options.signature) {
    params = clear_blank(options);
  } else {
    params.timestamp = timestamp();
    params = await sign_request(apiConfig, params, options);
  }
  return Promise.resolve(params);
}
function hashToParameters(hash) {
  return entries(hash).reduce((parameters, [key, value]) => {
    if ((0, _util.isArray)(value)) {
      key = key.endsWith('[]') ? key : key + '[]';
      const items = value.map(v => [key, v]);
      parameters = parameters.concat(items);
    } else {
      parameters.push([key, value]);
    }
    return parameters;
  }, []);
}
//# sourceMappingURL=index.js.map