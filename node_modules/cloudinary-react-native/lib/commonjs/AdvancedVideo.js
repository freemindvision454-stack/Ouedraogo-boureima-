"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _react = _interopRequireWildcard(require("react"));
var _SDKAnalyticsConstants = require("./internal/SDKAnalyticsConstants");
var _adapters = require("./adapters");
function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
class AdvancedVideo extends _react.Component {
  constructor(props) {
    super(props);
    this.videoRef = /*#__PURE__*/_react.default.createRef();
    const videoAdapter = _adapters.VideoPlayerFactory.getAvailableAdapter();
    this.state = {
      analyticsConnector: null,
      previousStatus: undefined,
      analyticsInitialized: false,
      videoAdapter
    };
  }
  async componentDidMount() {
    setTimeout(() => {
      if (this.props.enableAnalytics && this.videoRef.current) {
        this.initializeAnalytics();
      }
    }, 100);
  }
  componentDidUpdate(prevProps) {
    if (this.props.enableAnalytics && !prevProps.enableAnalytics && this.videoRef.current && !this.state.analyticsInitialized) {
      this.initializeAnalytics();
    }
  }
  componentWillUnmount() {
    if (this.state.analyticsConnector && this.state.analyticsConnector.stopManualTracking) {
      this.state.analyticsConnector.stopManualTracking();
    }
  }
  getVideoUri = () => {
    if (this.props.videoUrl) {
      return this.props.videoUrl;
    }
    if (this.props.cldVideo) {
      return this.props.cldVideo.toURL({
        trackedAnalytics: _SDKAnalyticsConstants.SDKAnalyticsConstants
      });
    }
    return '';
  };
  initializeAnalytics = async () => {
    if (!this.props.enableAnalytics || !this.videoRef.current || this.state.analyticsInitialized) {
      return;
    }
    try {
      const {
        connectCloudinaryAnalytics
      } = await Promise.resolve().then(() => _interopRequireWildcard(require('./widgets/video/analytics/cloudinary-analytics-react-native')));
      const videoUri = this.getVideoUri();
      if (this.videoRef.current) {
        if (!this.videoRef.current._currentStatus) {
          this.videoRef.current._currentStatus = {};
        }
        this.videoRef.current._currentStatus.uri = videoUri;
      }
      const connector = connectCloudinaryAnalytics(this.videoRef.current);
      if (this.props.autoTrackAnalytics) {
        connector.startAutoTracking(this.props.analyticsOptions || {});
      }
      this.setState({
        analyticsConnector: connector,
        analyticsInitialized: true
      });
    } catch (error) {
      // Silently fail if analytics initialization fails
    }
  };
  onPlaybackStatusUpdate = status => {
    var _this$props$onPlaybac, _this$props;
    if (this.props.enableAnalytics && this.videoRef.current && this.state.analyticsInitialized) {
      if (!this.videoRef.current._currentStatus) {
        this.videoRef.current._currentStatus = {};
      }
      this.videoRef.current._currentStatus = {
        ...status,
        uri: this.getVideoUri()
      };
      try {
        // Use the adapter's status processing if available
        if (this.state.videoAdapter.processStatusUpdate) {
          this.state.videoAdapter.processStatusUpdate(this.videoRef.current, status, this.state.previousStatus);
        }
        this.setState({
          previousStatus: status
        });
      } catch (error) {}
    }

    // Forward status updates to parent component
    (_this$props$onPlaybac = (_this$props = this.props).onPlaybackStatusUpdate) === null || _this$props$onPlaybac === void 0 || _this$props$onPlaybac.call(_this$props, status);
  };
  startAnalyticsTracking = (metadata, options) => {
    if (this.state.analyticsConnector) {
      try {
        this.state.analyticsConnector.startManualTracking(metadata, {
          ...this.props.analyticsOptions,
          ...options
        });
      } catch (error) {}
    }
  };
  stopAnalyticsTracking = () => {
    if (this.state.analyticsConnector) {
      try {
        this.state.analyticsConnector.stopManualTracking();
      } catch (error) {}
    }
  };
  startAutoAnalyticsTracking = options => {
    if (this.state.analyticsConnector) {
      try {
        this.state.analyticsConnector.startAutoTracking({
          ...this.props.analyticsOptions,
          ...options
        });
      } catch (error) {}
    }
  };
  addCustomEvent = (eventName, eventDetails = {}) => {
    if (!this.props.enableAnalytics) {
      return;
    }
    if (!this.state.analyticsInitialized) {
      return;
    }
    if (this.state.analyticsConnector && this.state.analyticsInitialized) {
      try {
        if (this.state.analyticsConnector.addCustomEvent) {
          this.state.analyticsConnector.addCustomEvent(eventName, eventDetails);
        }
      } catch (error) {}
    }
  };

  // Playback control methods
  playAsync = async () => {
    if (this.videoRef.current) {
      try {
        // expo-av uses setStatusAsync for playback control
        await this.videoRef.current.setStatusAsync({
          shouldPlay: true
        });
      } catch (error) {
        console.warn('Failed to play video:', error);
      }
    }
  };
  pauseAsync = async () => {
    if (this.videoRef.current) {
      try {
        // expo-av uses setStatusAsync for playback control
        await this.videoRef.current.setStatusAsync({
          shouldPlay: false
        });
      } catch (error) {
        console.warn('Failed to pause video:', error);
      }
    }
  };
  setIsMutedAsync = async isMuted => {
    if (this.videoRef.current) {
      try {
        // expo-av uses setStatusAsync for muting
        await this.videoRef.current.setStatusAsync({
          isMuted
        });
      } catch (error) {
        console.warn('Failed to set muted state:', error);
      }
    }
  };
  setPositionAsync = async positionMillis => {
    if (this.videoRef.current) {
      try {
        // expo-av uses setStatusAsync for seeking
        await this.videoRef.current.setStatusAsync({
          positionMillis
        });
      } catch (error) {
        console.warn('Failed to set position:', error);
      }
    }
  };
  setStatusAsync = async status => {
    if (this.videoRef.current) {
      try {
        // Forward to underlying video component
        await this.videoRef.current.setStatusAsync(status);
      } catch (error) {
        console.warn('Failed to set status:', error);
      }
    }
  };
  render() {
    const videoUri = this.getVideoUri();
    if (!videoUri) {
      return this.state.videoAdapter.renderVideo({
        videoUri: '',
        style: this.props.videoStyle
      }, this.videoRef);
    }
    try {
      const videoElement = this.state.videoAdapter.renderVideo({
        videoUri,
        style: this.props.videoStyle,
        useNativeControls: this.props.useNativeControls,
        onPlaybackStatusUpdate: this.onPlaybackStatusUpdate,
        onLoadStart: () => {},
        onLoad: () => {},
        onError: () => {}
      }, this.videoRef);
      return videoElement;
    } catch (error) {
      // If the adapter fails, fall back to a fallback adapter
      const {
        FallbackVideoAdapter
      } = require('./adapters/FallbackVideoAdapter');
      const fallbackAdapter = new FallbackVideoAdapter(error instanceof Error ? `Video Error: ${error.message}` : 'Unknown video error');
      return fallbackAdapter.renderVideo({
        videoUri,
        style: this.props.videoStyle
      }, this.videoRef);
    }
  }
}
var _default = exports.default = AdvancedVideo;
//# sourceMappingURL=AdvancedVideo.js.map