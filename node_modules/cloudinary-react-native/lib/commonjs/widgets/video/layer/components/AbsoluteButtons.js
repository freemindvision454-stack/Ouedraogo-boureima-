"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AbsoluteButtons = AbsoluteButtons;
var _react = _interopRequireDefault(require("react"));
var _reactNative = require("react-native");
var _vectorIcons = require("@expo/vector-icons");
var _types = require("../types");
var _constants = require("../constants");
var _utils = require("../utils");
var _styles = require("../styles");
var _CustomButton = require("./CustomButton");
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function AbsoluteButtons({
  isControlsVisible,
  onBack,
  backButtonPosition,
  shareButtonPosition,
  onShare,
  fullScreen,
  isFullScreen,
  onToggleFullScreen,
  buttonGroups,
  isLandscape
}) {
  if (!isControlsVisible) return null;
  const responsiveStyles = (0, _styles.getResponsiveStyles)(isLandscape);

  // Create default full screen button if enabled
  const defaultFullScreenButton = (fullScreen === null || fullScreen === void 0 ? void 0 : fullScreen.enabled) === true && fullScreen !== null && fullScreen !== void 0 && fullScreen.button ? {
    ...fullScreen.button,
    onPress: fullScreen.button.onPress || onToggleFullScreen
  } : (fullScreen === null || fullScreen === void 0 ? void 0 : fullScreen.enabled) === true ? {
    icon: isFullScreen ? 'contract-outline' : 'expand-outline',
    position: _types.ButtonPosition.NE,
    onPress: onToggleFullScreen
  } : null;

  // Process button groups format
  const processedButtonGroups = {};
  buttonGroups.forEach(group => {
    processedButtonGroups[group.position] = {
      buttons: group.buttons,
      layoutDirection: group.layoutDirection || _types.ButtonLayoutDirection.VERTICAL
    };
  });

  // Add default full screen button if enabled and not already in a group
  if (defaultFullScreenButton && !processedButtonGroups[_types.ButtonPosition.NE]) {
    processedButtonGroups[_types.ButtonPosition.NE] = {
      buttons: [defaultFullScreenButton],
      layoutDirection: _types.ButtonLayoutDirection.VERTICAL
    };
  } else if (defaultFullScreenButton && processedButtonGroups[_types.ButtonPosition.NE]) {
    // Check if full screen button is already in the group to avoid duplicates
    const existingButtons = processedButtonGroups[_types.ButtonPosition.NE].buttons;
    const hasFullScreenButton = existingButtons.some(button => button.icon === defaultFullScreenButton.icon || button.icon === 'expand-outline' || button.icon === 'contract-outline');
    if (!hasFullScreenButton) {
      processedButtonGroups[_types.ButtonPosition.NE].buttons.push(defaultFullScreenButton);
    }
  }

  // Filter for absolute positioning (not in top controls bar)
  const absolutePositions = [_types.ButtonPosition.SE, _types.ButtonPosition.SW, _types.ButtonPosition.S, _types.ButtonPosition.E, _types.ButtonPosition.W];
  const absoluteButtonGroups = Object.entries(processedButtonGroups).filter(([position]) => absolutePositions.includes(position));

  // Render buttons with enhanced spacing and layout direction
  const renderedButtons = [];
  absoluteButtonGroups.forEach(([position, {
    buttons,
    layoutDirection
  }]) => {
    buttons.forEach((button, index) => {
      // Get base position style
      const basePositionStyle = (() => {
        switch (button.position) {
          case _types.ButtonPosition.SE:
            return responsiveStyles.buttonPositionSE;
          case _types.ButtonPosition.SW:
            return responsiveStyles.buttonPositionSW;
          case _types.ButtonPosition.S:
            return responsiveStyles.buttonPositionS;
          case _types.ButtonPosition.E:
            return responsiveStyles.buttonPositionE;
          case _types.ButtonPosition.W:
            return responsiveStyles.buttonPositionW;
          default:
            return {};
        }
      })();

      // Calculate spacing offset with layout direction support
      const spacingStyle = (0, _utils.calculateButtonPosition)(position, index, buttons.length, isLandscape, layoutDirection);

      // Combine base position with spacing
      const finalStyle = {
        ...basePositionStyle,
        ...spacingStyle
      };
      renderedButtons.push(/*#__PURE__*/_react.default.createElement(_CustomButton.CustomButton, {
        key: `absolute-${position}-${index}`,
        config: button,
        isLandscape: isLandscape,
        style: finalStyle,
        defaultOnPress: button === defaultFullScreenButton ? onToggleFullScreen : undefined
      }));
    });
  });
  return /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, onBack && backButtonPosition === _types.ButtonPosition.SE && /*#__PURE__*/_react.default.createElement(_reactNative.TouchableOpacity, {
    style: [responsiveStyles.topButton, responsiveStyles.buttonPositionSE],
    onPress: onBack
  }, /*#__PURE__*/_react.default.createElement(_vectorIcons.Ionicons, {
    name: "close",
    size: _constants.ICON_SIZES.top,
    color: "white"
  })), shareButtonPosition === _types.ButtonPosition.SE && /*#__PURE__*/_react.default.createElement(_reactNative.TouchableOpacity, {
    style: [responsiveStyles.topButton, responsiveStyles.buttonPositionSE],
    onPress: onShare
  }, /*#__PURE__*/_react.default.createElement(_vectorIcons.Ionicons, {
    name: "share-outline",
    size: _constants.ICON_SIZES.top,
    color: "white"
  })), renderedButtons);
}
//# sourceMappingURL=AbsoluteButtons.js.map