"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useVideoSeeking = exports.useVideoControlsVisibility = exports.useOrientation = void 0;
var _react = _interopRequireDefault(require("react"));
var _reactNative = require("react-native");
var _constants = require("./constants");
var _utils = require("./utils");
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
/**
 * Custom hook for managing video controls visibility and auto-hide functionality
 */
const useVideoControlsVisibility = () => {
  const fadeAnim = _react.default.useRef(new _reactNative.Animated.Value(1)).current;
  const autoHideTimeoutId = _react.default.useRef(null);
  const clearAutoHideTimer = _react.default.useCallback(() => {
    if (autoHideTimeoutId.current) {
      clearTimeout(autoHideTimeoutId.current);
      autoHideTimeoutId.current = null;
    }
  }, []);
  const startAutoHideTimer = _react.default.useCallback((isControlsVisible, setIsControlsVisible) => {
    clearAutoHideTimer();
    autoHideTimeoutId.current = setTimeout(() => {
      if (isControlsVisible) {
        setIsControlsVisible(false);
        _reactNative.Animated.timing(fadeAnim, {
          toValue: 0,
          duration: _constants.CONTROLS_FADE_DURATION,
          easing: _reactNative.Easing.linear,
          useNativeDriver: true
        }).start();
      }
    }, _constants.CONTROLS_AUTO_HIDE_DELAY);
  }, [fadeAnim, clearAutoHideTimer]);
  const toggleControls = _react.default.useCallback((isControlsVisible, setIsControlsVisible) => {
    const newVisibility = !isControlsVisible;
    setIsControlsVisible(newVisibility);
    _reactNative.Animated.timing(fadeAnim, {
      toValue: newVisibility ? 1 : 0,
      duration: _constants.CONTROLS_FADE_DURATION,
      easing: _reactNative.Easing.linear,
      useNativeDriver: true
    }).start();
    if (newVisibility) {
      startAutoHideTimer(newVisibility, setIsControlsVisible);
    } else {
      clearAutoHideTimer();
    }
  }, [fadeAnim, startAutoHideTimer, clearAutoHideTimer]);

  // Cleanup on unmount
  _react.default.useEffect(() => {
    return () => {
      clearAutoHideTimer();
    };
  }, [clearAutoHideTimer]);
  return {
    fadeAnim,
    startAutoHideTimer,
    clearAutoHideTimer,
    toggleControls
  };
};

/**
 * Custom hook for managing video seeking functionality
 */
exports.useVideoControlsVisibility = useVideoControlsVisibility;
const useVideoSeeking = () => {
  const seekTimeoutId = _react.default.useRef(null);
  const lastSeekTime = _react.default.useRef(0);
  const handleSeekStart = _react.default.useCallback(() => {
    return {
      isSeeking: true
    };
  }, []);
  const handleSeekMove = _react.default.useCallback((evt, seekbarRef, status) => {
    if (seekbarRef.current && status) {
      const touchPageX = evt.nativeEvent.pageX;
      return new Promise(resolve => {
        seekbarRef.current.measure((_x, _y, width, _height, pageX, _pageY) => {
          const touchX = touchPageX - pageX;
          const progress = (0, _utils.calculateSeekProgress)(touchX, width);
          const seekPosition = progress * (status.durationMillis || 0);
          resolve({
            seekingPosition: seekPosition
          });
        });
      });
    }
    return Promise.resolve({
      seekingPosition: 0
    });
  }, []);
  const handleSeekEnd = _react.default.useCallback((evt, seekbarRef, status, videoRef) => {
    if (seekbarRef.current && status) {
      const touchPageX = evt.nativeEvent.pageX;
      return new Promise(resolve => {
        seekbarRef.current.measure((_x, _y, width, _height, pageX, _pageY) => {
          const touchX = touchPageX - pageX;
          const progress = (0, _utils.calculateSeekProgress)(touchX, width);
          const duration = status.durationMillis || 0;
          const seekPosition = progress * duration;
          if (videoRef.current && status && duration > 0) {
            const validSeekPosition = (0, _utils.validateSeekPosition)(seekPosition, duration);
            const currentPosition = status.positionMillis || 0;
            const positionDiff = (0, _utils.hasSignificantPositionDifference)(validSeekPosition, currentPosition, _constants.SEEK_POSITION_THRESHOLD);
            const now = Date.now();
            const timeSinceLastSeek = now - lastSeekTime.current;
            if (positionDiff && timeSinceLastSeek > _constants.SEEK_DEBOUNCE_DELAY) {
              if (status.isLoaded && status.durationMillis && status.durationMillis > 0 && validSeekPosition >= 0 && validSeekPosition < status.durationMillis) {
                lastSeekTime.current = now;
                videoRef.current.setStatusAsync({
                  positionMillis: validSeekPosition
                }).catch(error => {
                  console.warn('Seek failed:', error);
                  resolve({
                    isSeeking: false,
                    seekingPosition: 0,
                    lastSeekPosition: 0,
                    isSeekingComplete: false
                  });
                });
              }
            }
            resolve({
              isSeeking: false,
              seekingPosition: validSeekPosition,
              lastSeekPosition: validSeekPosition,
              isSeekingComplete: true
            });
          } else {
            resolve({
              isSeeking: false,
              seekingPosition: 0,
              lastSeekPosition: 0,
              isSeekingComplete: false
            });
          }
        });
      });
    }
    return Promise.resolve({
      isSeeking: false,
      seekingPosition: 0,
      lastSeekPosition: 0,
      isSeekingComplete: false
    });
  }, []);
  const getProgress = _react.default.useCallback((status, isSeeking, seekingPosition, isSeekingComplete, lastSeekPosition) => {
    if (!status) return 0;
    const duration = status.durationMillis || 1;
    const currentVideoPosition = status.positionMillis || 0;
    if (isSeeking) {
      return seekingPosition / duration;
    }
    if (isSeekingComplete && lastSeekPosition > 0) {
      return lastSeekPosition / duration;
    }
    return currentVideoPosition / duration;
  }, []);
  const getCurrentPosition = _react.default.useCallback((status, isSeeking, seekingPosition, isSeekingComplete, lastSeekPosition) => {
    if (!status) return 0;
    const currentVideoPosition = status.positionMillis || 0;
    if (isSeeking) {
      return seekingPosition;
    }
    if (isSeekingComplete && lastSeekPosition > 0) {
      return lastSeekPosition;
    }
    return currentVideoPosition;
  }, []);
  const handleStatusUpdate = _react.default.useCallback((s, isSeekingComplete, lastSeekPosition, setStatus, setSeekingState) => {
    if (s.isLoaded) {
      if (isSeekingComplete && lastSeekPosition > 0) {
        const currentVideoPosition = s.positionMillis || 0;
        const seekPositionDiff = Math.abs(currentVideoPosition - lastSeekPosition);
        if (seekPositionDiff < _constants.SEEK_POSITION_TOLERANCE) {
          setStatus(s);
          setSeekingState({
            isSeekingComplete: false,
            lastSeekPosition: 0
          });
          return;
        }
      }
      setStatus(s);
    }
  }, []);

  // Cleanup on unmount
  _react.default.useEffect(() => {
    return () => {
      if (seekTimeoutId.current) {
        clearTimeout(seekTimeoutId.current);
        seekTimeoutId.current = null;
      }
    };
  }, []);
  return {
    handleSeekStart,
    handleSeekMove,
    handleSeekEnd,
    getProgress,
    getCurrentPosition,
    handleStatusUpdate
  };
};

/**
 * Custom hook for managing device orientation detection
 */
exports.useVideoSeeking = useVideoSeeking;
const useOrientation = () => {
  const [isLandscape, setIsLandscape] = _react.default.useState(false);
  _react.default.useEffect(() => {
    const {
      Dimensions
    } = require('react-native');
    const updateOrientation = () => {
      const {
        width,
        height
      } = Dimensions.get('window');
      setIsLandscape(width > height);
    };

    // Set initial orientation
    updateOrientation();

    // Listen for orientation changes
    const subscription = Dimensions.addEventListener('change', updateOrientation);
    return () => {
      if (subscription !== null && subscription !== void 0 && subscription.remove) {
        subscription.remove();
      }
    };
  }, []);
  return {
    isLandscape
  };
};
exports.useOrientation = useOrientation;
//# sourceMappingURL=hooks.js.map