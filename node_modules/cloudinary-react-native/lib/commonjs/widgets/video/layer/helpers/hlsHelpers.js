"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseHLSQualityLevelsIfNeeded = parseHLSQualityLevelsIfNeeded;
exports.parseHLSSubtitlesIfNeeded = parseHLSSubtitlesIfNeeded;
var _utils = require("../utils");
async function parseHLSSubtitlesIfNeeded(props, updateState) {
  const videoUrl = (0, _utils.getVideoUrl)(props.videoUrl, props.cldVideo);
  if ((0, _utils.isHLSVideo)(videoUrl)) {
    try {
      const subtitleTracks = await (0, _utils.parseHLSManifest)(videoUrl);
      const availableSubtitleTracks = [{
        code: 'off',
        label: 'Off'
      }, ...subtitleTracks];
      updateState({
        availableSubtitleTracks
      });
    } catch (error) {
      console.warn('Failed to parse HLS subtitles:', error);
      updateState({
        availableSubtitleTracks: [{
          code: 'off',
          label: 'Off'
        }]
      });
    }
  }
}
async function parseHLSQualityLevelsIfNeeded(props, updateState) {
  const videoUrl = (0, _utils.getVideoUrl)(props.videoUrl, props.cldVideo);
  if ((0, _utils.isHLSVideo)(videoUrl)) {
    try {
      const qualityLevels = await (0, _utils.parseHLSQualityLevels)(videoUrl);
      const availableQualityLevels = [{
        value: 'auto',
        label: 'Auto'
      }, ...qualityLevels];
      updateState({
        availableQualityLevels
      });
    } catch (error) {
      console.warn('Failed to parse HLS quality levels:', error);
      updateState({
        availableQualityLevels: [{
          value: 'auto',
          label: 'Auto'
        }]
      });
    }
  }
}
//# sourceMappingURL=hlsHelpers.js.map