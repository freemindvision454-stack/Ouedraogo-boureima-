"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseWebVTT = exports.findActiveSubtitle = exports.fetchSubtitleFile = void 0;
/**
 * WebVTT parsing utilities for subtitle support
 */

/**
 * Parse WebVTT file content into subtitle cues
 */
const parseWebVTT = content => {
  const cues = [];

  // Split content into lines and remove BOM if present
  const lines = content.replace(/^\ufeff/, '').split('\n');
  let i = 0;

  // Skip header
  while (i < lines.length && !((_lines$i = lines[i]) !== null && _lines$i !== void 0 && _lines$i.includes('-->'))) {
    var _lines$i;
    i++;
  }

  // Parse cues
  while (i < lines.length) {
    var _lines$i2;
    const line = (_lines$i2 = lines[i]) === null || _lines$i2 === void 0 ? void 0 : _lines$i2.trim();
    if (line !== null && line !== void 0 && line.includes('-->')) {
      // Found a time line
      const timeMatch = line.match(/(\d{2}:\d{2}:\d{2}\.\d{3})\s*-->\s*(\d{2}:\d{2}:\d{2}\.\d{3})/);
      if (timeMatch && timeMatch[1] && timeMatch[2]) {
        const startTime = parseVTTTime(timeMatch[1]);
        const endTime = parseVTTTime(timeMatch[2]);

        // Collect subtitle text lines
        i++;
        const textLines = [];
        while (i < lines.length && ((_lines$i3 = lines[i]) === null || _lines$i3 === void 0 ? void 0 : _lines$i3.trim()) !== '') {
          var _lines$i3, _lines$i4;
          const textLine = (_lines$i4 = lines[i]) === null || _lines$i4 === void 0 ? void 0 : _lines$i4.trim();
          if (textLine) {
            textLines.push(textLine);
          }
          i++;
        }
        if (textLines.length > 0) {
          cues.push({
            start: startTime,
            end: endTime,
            text: textLines.join('\n').replace(/<[^>]*>/g, '') // Strip HTML tags for now
          });
        }
      }
    }
    i++;
  }
  return cues;
};

/**
 * Parse VTT time format (HH:MM:SS.mmm) to seconds
 */
exports.parseWebVTT = parseWebVTT;
const parseVTTTime = timeStr => {
  const parts = timeStr.split(':');
  const lastPart = parts[parts.length - 1];
  if (!lastPart) return 0;
  const seconds = lastPart.split('.');
  const hours = parseInt(parts[0] || '0', 10);
  const minutes = parseInt(parts[1] || '0', 10);
  const secs = parseInt(seconds[0] || '0', 10);
  const milliseconds = parseInt(seconds[1] || '0', 10);
  return hours * 3600 + minutes * 60 + secs + milliseconds / 1000;
};

/**
 * Find active subtitle cue for given time
 */
const findActiveSubtitle = (cues, currentTime) => {
  return cues.find(cue => currentTime >= cue.start && currentTime <= cue.end) || null;
};

/**
 * Parse M3U8 playlist content to extract VTT file URL
 */
exports.findActiveSubtitle = findActiveSubtitle;
const parseM3U8ForVTTUrl = (content, baseUrl) => {
  const lines = content.split('\n');
  for (const line of lines) {
    const trimmedLine = line.trim();
    // Look for lines that end with .vtt and don't start with #
    if (!trimmedLine.startsWith('#') && trimmedLine.includes('.vtt')) {
      let vttUrl = trimmedLine;

      // Resolve relative URL if needed
      if (vttUrl.startsWith('/')) {
        const urlObj = new URL(baseUrl);
        vttUrl = `${urlObj.protocol}//${urlObj.host}${vttUrl}`;
      } else if (!vttUrl.startsWith('http')) {
        const basePath = baseUrl.substring(0, baseUrl.lastIndexOf('/') + 1);
        vttUrl = basePath + vttUrl;
      }
      return vttUrl;
    }
  }
  return null;
};

/**
 * Fetch and parse subtitle file from URL
 */
const fetchSubtitleFile = async url => {
  try {
    const response = await fetch(url);
    if (!response.ok) {
      throw new Error(`Failed to fetch subtitle file: ${response.status}`);
    }
    const content = await response.text();

    // Check if this is an M3U8 playlist instead of a VTT file
    if (content.trim().startsWith('#EXTM3U')) {
      const vttUrl = parseM3U8ForVTTUrl(content, url);
      if (vttUrl) {
        // Recursively fetch the actual VTT file
        return await fetchSubtitleFile(vttUrl);
      } else {
        console.warn('No VTT URL found in M3U8 playlist');
        return [];
      }
    }

    // Content is already VTT, parse it directly
    const cues = parseWebVTT(content);
    return cues;
  } catch (error) {
    console.warn('Failed to fetch subtitle file:', error);
    return [];
  }
};
exports.fetchSubtitleFile = fetchSubtitleFile;
//# sourceMappingURL=subtitleUtils.js.map