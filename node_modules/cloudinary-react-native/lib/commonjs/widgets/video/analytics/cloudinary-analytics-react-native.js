"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.connectCloudinaryAnalytics = void 0;
var _eventsCollector = require("./events-collector");
var _uniqueIds = require("./utils/unique-ids");
var _sendRequestReactNative = require("./utils/send-request-react-native");
var _events = require("./utils/events");
var _validators = require("./utils/validators");
var _expoAVVideoPlayerAdapter = require("./player-adapters/expoAVVideoPlayerAdapter");
var _customerData = require("./utils/customer-data");
var _appStateEvents = require("./utils/app-state-events");
const CLD_ANALYTICS_ENDPOINTS_LIST = {
  production: {
    default: 'https://video-analytics-api.cloudinary.com/v1/video-analytics',
    liveStreams: 'https://video-analytics-api.cloudinary.com/v1/live-streams'
  },
  development: {
    default: 'http://localhost:3001/events',
    liveStreams: 'http://localhost:3001/events'
  }
};
const CLD_ANALYTICS_ENDPOINT = CLD_ANALYTICS_ENDPOINTS_LIST.production;
const connectCloudinaryAnalytics = (videoRef, mainOptions = {}) => {
  (0, _validators.throwErrorIfInvalid)((0, _validators.mainOptionsValidator)(mainOptions), 'Cloudinary video analytics requires proper options object');
  if (!mainOptions.playerAdapter) {
    mainOptions.playerAdapter = (0, _expoAVVideoPlayerAdapter.expoAVVideoPlayerAdapter)(videoRef);
  }
  let videoTrackingSession = null;
  const userId = (0, _uniqueIds.getUserId)();
  const {
    playerAdapter
  } = mainOptions;
  const createEventsCollector = (0, _eventsCollector.initEventsCollector)(playerAdapter);
  const clearVideoTracking = () => {
    if (videoTrackingSession) {
      videoTrackingSession.clear();
      videoTrackingSession = null;
    }
  };
  const viewId = {
    _value: (0, _uniqueIds.getVideoViewId)(),
    getValue: () => viewId._value,
    regenerateValue: () => {
      viewId._value = (0, _uniqueIds.getVideoViewId)();
      if (videoTrackingSession) {
        videoTrackingSession.viewId = viewId._value;
      }
      return viewId._value;
    }
  };
  const startManualTracking = (metadata, options = {}) => {
    var _videoTrackingSession;
    if (((_videoTrackingSession = videoTrackingSession) === null || _videoTrackingSession === void 0 ? void 0 : _videoTrackingSession.type) === 'auto') {
      throw 'Cloudinary video analytics auto tracking is already connected with this Video component, to start manual tracking you need to stop auto tracking';
    }
    (0, _validators.throwErrorIfInvalid)((0, _validators.metadataValidator)(metadata), 'Cloudinary video analytics manual tracking called without necessary data');
    (0, _validators.throwErrorIfInvalid)((0, _validators.trackingOptionsValidator)(options), 'Cloudinary video analytics manual tracking called with invalid options');
    clearVideoTracking();
    if (metadata.type === 'live') {
      _startManualTrackingLiveStream(metadata, options);
    } else {
      options.customVideoUrlFallback = options.customVideoUrlFallback || (() => metadata);
      _startManualTrackingRegularVideo(metadata, options);
    }
  };
  const _startManualTrackingRegularVideo = (metadata, options) => {
    const sendData = data => {
      return (0, _sendRequestReactNative.sendRequest)(CLD_ANALYTICS_ENDPOINT.default, data);
    };
    const videoViewEventCollector = createEventsCollector();
    const finishVideoTracking = () => {
      if (videoViewEventCollector.getCollectedEventsCount() > 0) {
        videoViewEventCollector.addEvent((0, _events.createRegularVideoViewEndEvent)());
        const events = (0, _events.prepareEvents)([...videoViewEventCollector.flushEvents()]);
        sendData({
          userId,
          viewId: viewId.getValue(),
          events
        });
        videoViewEventCollector.destroy();
      }
    };
    const appStateRemoval = (0, _appStateEvents.createAppStateTracker)({
      onAppForeground: () => {
        viewId.regenerateValue();
        videoViewEventCollector.start(viewId.getValue());
        videoViewEventCollector.addEvent((0, _events.createRegularVideoViewStartEvent)({
          videoUrl: playerAdapter.getCurrentSrc(),
          trackingType: 'manual'
        }, options));
      },
      onAppBackground: () => {
        finishVideoTracking();
      }
    });
    videoTrackingSession = {
      viewId,
      type: 'manual',
      subtype: 'default',
      eventCollector: videoViewEventCollector,
      clear: () => {
        finishVideoTracking();
        appStateRemoval();
      }
    };
  };
  const _startManualTrackingLiveStream = (metadata, options) => {
    const liveStreamData = (0, _customerData.parseCustomerVideoData)(metadata);
    const sendLiveStreamEvent = event => {
      (0, _sendRequestReactNative.sendRequest)(CLD_ANALYTICS_ENDPOINT.liveStreams, {
        userId,
        viewId: viewId.getValue(),
        events: (0, _events.prepareEvents)([event])
      });
    };
    const appStateRemoval = (0, _appStateEvents.createAppStateTracker)({
      onAppForeground: () => {
        viewId.regenerateValue();
        sendLiveStreamEvent((0, _events.createLiveStreamViewStartEvent)({
          liveStreamData
        }, options));
      },
      onAppBackground: () => {
        sendLiveStreamEvent((0, _events.createLiveStreamViewEndEvent)({
          liveStreamData
        }, options));
      }
    });
    videoTrackingSession = {
      viewId: viewId.getValue(),
      type: 'manual',
      subtype: 'live-stream',
      clear: () => {
        appStateRemoval();
      }
    };
  };
  const startAutoTracking = (options = {}) => {
    if (videoTrackingSession) {
      throw 'Cloudinary video analytics tracking is already connected with this Video component';
    }
    (0, _validators.throwErrorIfInvalid)((0, _validators.trackingOptionsValidator)(options), 'Cloudinary video analytics auto tracking called with invalid options');
    const sendData = data => {
      return (0, _sendRequestReactNative.sendRequest)(CLD_ANALYTICS_ENDPOINT.default, data);
    };
    const videoViewEventCollector = createEventsCollector();
    const finishVideoTracking = () => {
      if (videoTrackingSession && videoViewEventCollector.getCollectedEventsCount() > 0) {
        videoViewEventCollector.addEvent((0, _events.createRegularVideoViewEndEvent)());
        const events = (0, _events.prepareEvents)([...videoViewEventCollector.flushEvents()]);
        sendData({
          userId,
          viewId: viewId.getValue(),
          events
        });
        videoViewEventCollector.destroy();
      }
    };
    const startVideoTracking = () => {
      const sourceUrl = playerAdapter.getCurrentSrc();
      if (!videoTrackingSession) {
        return null;
      }
      if (!sourceUrl) {
        return null;
      }
      if (!videoTrackingSession.viewStarted) {
        viewId.regenerateValue();
        videoViewEventCollector.start(viewId.getValue());
        videoViewEventCollector.addEvent((0, _events.createRegularVideoViewStartEvent)({
          videoUrl: sourceUrl,
          trackingType: 'auto'
        }, options));
        videoTrackingSession.viewStarted = true;
      }
    };
    videoTrackingSession = {
      viewId,
      type: 'auto',
      eventCollector: videoViewEventCollector,
      viewStarted: false,
      clear: () => {
        finishVideoTracking();
      }
    };
    (0, _appStateEvents.createAppStateTracker)({
      onAppForeground: () => startVideoTracking(),
      onAppBackground: () => {
        if (videoTrackingSession) {
          finishVideoTracking();
        }
      }
    });
    playerAdapter.onLoadStart(() => {
      if (videoTrackingSession) {
        startVideoTracking();
      }
    });
    playerAdapter.onEmptied(() => clearVideoTracking());
    setTimeout(() => {
      startVideoTracking();
    }, 100);
  };
  const addCustomEvent = (eventName, eventDetails = {}) => {
    if (!videoTrackingSession) {
      try {
        const videoViewEventCollector = createEventsCollector();
        viewId.regenerateValue();
        videoViewEventCollector.start(viewId.getValue());
        videoTrackingSession = {
          viewId,
          type: 'custom-events-only',
          eventCollector: videoViewEventCollector,
          viewStarted: true,
          clear: () => {
            if (videoViewEventCollector.getCollectedEventsCount() > 0) {
              const events = (0, _events.prepareEvents)([...videoViewEventCollector.flushEvents()]);
              (0, _sendRequestReactNative.sendRequest)(CLD_ANALYTICS_ENDPOINT.default, {
                userId,
                viewId: viewId.getValue(),
                events
              });
            }
            videoViewEventCollector.destroy();
          }
        };
      } catch (error) {
        return;
      }
    }
    if (!videoTrackingSession || !videoTrackingSession.eventCollector) {
      return;
    }
    try {
      if (videoTrackingSession.type === 'auto' && !videoTrackingSession.viewStarted) {
        viewId.regenerateValue();
        videoTrackingSession.eventCollector.start(viewId.getValue());
        videoTrackingSession.viewStarted = true;
      }
      videoTrackingSession.eventCollector.addEvent({
        eventName,
        eventDetails,
        timestamp: Date.now()
      });
    } catch (error) {}
  };
  return {
    startManualTracking,
    stopManualTracking: clearVideoTracking,
    startAutoTracking,
    addCustomEvent
  };
};
exports.connectCloudinaryAnalytics = connectCloudinaryAnalytics;
//# sourceMappingURL=cloudinary-analytics-react-native.js.map