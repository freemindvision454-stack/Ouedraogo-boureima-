"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ExpoVideoAdapter = void 0;
var _react = _interopRequireDefault(require("react"));
var _types = require("./types");
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
// ExpoVideoAdapter - handles expo-video integration
// Currently disabled due to hooks compatibility issues with class-based adapter system

class ExpoVideoAdapter {
  expoVideoModule = null;
  playerCache = new Map();
  constructor() {
    this.loadExpoVideo();
  }
  loadExpoVideo() {
    try {
      this.expoVideoModule = require('expo-video');
    } catch (error) {
      this.expoVideoModule = null;
    }
  }
  isAvailable() {
    // Check if expo-video module loaded successfully and has Video component
    return !!(this.expoVideoModule && this.expoVideoModule.VideoView);
  }
  getAdapterName() {
    return _types.VideoPlayerType.EXPO_VIDEO;
  }
  renderVideo(props, ref) {
    var _player$source;
    if (!this.isAvailable()) {
      throw new Error('expo-video is not available');
    }
    const {
      VideoView,
      createVideoPlayer
    } = this.expoVideoModule;

    // Get or create cached player for this URI
    let player = this.playerCache.get(props.videoUri);
    if (!player) {
      player = createVideoPlayer({
        uri: props.videoUri
      });

      // Configure player properties with initial values
      player.loop = false;
      player.muted = false;
      player.playbackRate = 1.0;
      this.playerCache.set(props.videoUri, player);
    }

    // Handle URI changes for quality/source switching
    if (((_player$source = player.source) === null || _player$source === void 0 ? void 0 : _player$source.uri) !== props.videoUri) {
      try {
        // Store current playback state
        const wasPlaying = player.playing;
        const currentTime = player.currentTime || 0;

        // Update source
        player.source = {
          uri: props.videoUri
        };

        // Restore playback state after a brief delay
        setTimeout(() => {
          try {
            if (currentTime > 0) {
              player.currentTime = currentTime;
            }
            if (wasPlaying) {
              player.play();
            }
          } catch (error) {
            // Silently handle playback state restoration errors
          }
        }, 100);
      } catch (error) {
        // Silently handle source update errors
      }
    }

    // Set up event listeners for status updates only once per player
    if (props.onPlaybackStatusUpdate && !player._listenersSetup) {
      const sendStatusUpdate = () => {
        const status = {
          uri: props.videoUri,
          isLoaded: true,
          shouldPlay: player.playing || false,
          isPlaying: player.playing || false,
          positionMillis: (player.currentTime || 0) * 1000,
          durationMillis: (player.duration || 0) * 1000,
          isMuted: player.muted || false,
          rate: player.playbackRate || 1.0,
          volume: player.muted ? 0 : 1.0
        };
        if (props.onPlaybackStatusUpdate) {
          props.onPlaybackStatusUpdate(status);
        }
        return status;
      };

      // Listen to various player events and map them to status updates
      const playingChangeHandler = () => {
        sendStatusUpdate();
      };
      const statusChangeHandler = () => {
        sendStatusUpdate();
      };
      const timeUpdateHandler = () => {
        // Send time updates for seekbar
        sendStatusUpdate();
      };
      const loadedHandler = () => {
        sendStatusUpdate();
      };

      // Set up a timer to continuously update time during playback
      let timeUpdateInterval = null;
      const startTimeUpdates = () => {
        if (timeUpdateInterval) clearInterval(timeUpdateInterval);
        timeUpdateInterval = setInterval(() => {
          if (player.playing) {
            sendStatusUpdate();
          }
        }, 250); // Update 4 times per second
      };
      const stopTimeUpdates = () => {
        if (timeUpdateInterval) {
          clearInterval(timeUpdateInterval);
          timeUpdateInterval = null;
        }
      };
      const enhancedPlayingChangeHandler = isPlaying => {
        if (isPlaying) {
          startTimeUpdates();
        } else {
          stopTimeUpdates();
        }
        sendStatusUpdate();
      };
      player.addListener('playingChange', enhancedPlayingChangeHandler);
      player.addListener('statusChange', statusChangeHandler);

      // Try multiple possible event names for time updates
      try {
        player.addListener('timeUpdate', timeUpdateHandler);
      } catch (e) {}
      try {
        player.addListener('playbackStatusUpdate', timeUpdateHandler);
      } catch (e) {}
      try {
        player.addListener('loadeddata', loadedHandler);
      } catch (e) {}

      // Mark listeners as setup to prevent duplicates
      player._listenersSetup = true;
      player._handlers = {
        playingChangeHandler: enhancedPlayingChangeHandler,
        statusChangeHandler,
        timeUpdateHandler,
        loadedHandler,
        stopTimeUpdates
      };

      // Send initial status
      setTimeout(() => sendStatusUpdate(), 100);
    }

    // Handle errors
    if (props.onError) {
      player.addListener('error', error => {
        props.onError(error);
      });
    }
    return /*#__PURE__*/_react.default.createElement(VideoView, {
      ref: videoInstance => {
        if (ref && typeof ref === 'object' && 'current' in ref) {
          // Store the player reference for compatibility with existing code
          ref.current = {
            ...videoInstance,
            // Add expo-av compatible methods for backward compatibility
            setStatusAsync: async status => {
              try {
                let statusChanged = false;
                if (status.shouldPlay !== undefined) {
                  if (status.shouldPlay) {
                    await player.play();
                    statusChanged = true;
                  } else {
                    player.pause();
                    statusChanged = true;
                  }
                }
                if (status.positionMillis !== undefined) {
                  player.currentTime = status.positionMillis / 1000;
                  statusChanged = true;
                }
                if (status.isMuted !== undefined) {
                  player.muted = status.isMuted;
                  statusChanged = true;
                }
                if (status.rate !== undefined) {
                  player.playbackRate = status.rate;
                  statusChanged = true;
                }
                if (status.uri !== undefined && status.uri !== props.videoUri) {
                  try {
                    // Handle source changes (quality switching)
                    const wasPlaying = player.playing;
                    const currentTime = player.currentTime || 0;
                    player.source = {
                      uri: status.uri
                    };

                    // Restore state
                    setTimeout(() => {
                      if (status.positionMillis !== undefined) {
                        player.currentTime = status.positionMillis / 1000;
                      } else if (currentTime > 0) {
                        player.currentTime = currentTime;
                      }
                      if (status.shouldPlay !== undefined ? status.shouldPlay : wasPlaying) {
                        player.play();
                      }
                    }, 100);
                    statusChanged = true;
                  } catch (error) {
                    console.warn('ExpoVideoAdapter - URI change failed:', error);
                  }
                }

                // Send status update after changes
                if (statusChanged && props.onPlaybackStatusUpdate) {
                  setTimeout(() => {
                    const newStatus = {
                      uri: props.videoUri,
                      isLoaded: true,
                      shouldPlay: player.playing || false,
                      isPlaying: player.playing || false,
                      positionMillis: (player.currentTime || 0) * 1000,
                      durationMillis: (player.duration || 0) * 1000,
                      isMuted: player.muted || false,
                      rate: player.playbackRate || 1.0,
                      volume: player.muted ? 0 : 1.0
                    };
                    props.onPlaybackStatusUpdate(newStatus);
                  }, 50);
                }
              } catch (error) {
                console.warn('ExpoVideoAdapter - setStatusAsync error:', error);
              }
            },
            // Add missing expo-av compatible method for mute toggle
            setIsMutedAsync: async isMuted => {
              try {
                player.muted = isMuted;
                // Send status update after mute change
                if (props.onPlaybackStatusUpdate) {
                  setTimeout(() => {
                    const newStatus = {
                      uri: props.videoUri,
                      isLoaded: true,
                      shouldPlay: player.playing || false,
                      isPlaying: player.playing || false,
                      positionMillis: (player.currentTime || 0) * 1000,
                      durationMillis: (player.duration || 0) * 1000,
                      isMuted: player.muted || false,
                      rate: player.playbackRate || 1.0,
                      volume: player.muted ? 0 : 1.0
                    };
                    if (props.onPlaybackStatusUpdate) {
                      props.onPlaybackStatusUpdate(newStatus);
                    }
                  }, 50);
                }
              } catch (error) {
                // Silently handle mute errors
              }
            },
            // Add cleanup method
            _cleanup: () => {
              try {
                if (player._handlers) {
                  player.removeListener('playingChange', player._handlers.playingChangeHandler);
                  player.removeListener('statusChange', player._handlers.statusChangeHandler);

                  // Clean up time update interval
                  if (player._handlers.stopTimeUpdates) {
                    player._handlers.stopTimeUpdates();
                  }
                  try {
                    player.removeListener('timeUpdate', player._handlers.timeUpdateHandler);
                  } catch (e) {}
                  try {
                    player.removeListener('loadeddata', player._handlers.loadedHandler);
                  } catch (e) {}
                }
                player.remove();
              } catch (error) {
                console.warn('ExpoVideoAdapter - cleanup error:', error);
              }
            },
            _currentStatus: {
              uri: props.videoUri,
              isLoaded: true,
              shouldPlay: player.playing || false,
              positionMillis: (player.currentTime || 0) * 1000,
              durationMillis: (player.duration || 0) * 1000,
              isMuted: player.muted || false,
              rate: player.playbackRate || 1.0,
              volume: player.muted ? 0 : 1.0
            }
          };
        }
      },
      player: player,
      style: props.style,
      nativeControls: props.useNativeControls || false,
      contentFit: 'contain',
      onLoad: data => {
        var _props$onLoad;
        (_props$onLoad = props.onLoad) === null || _props$onLoad === void 0 || _props$onLoad.call(props, data);
      },
      onLoadStart: data => {
        var _props$onLoadStart;
        (_props$onLoadStart = props.onLoadStart) === null || _props$onLoadStart === void 0 || _props$onLoadStart.call(props, data);
      }
    });
  }
  processExpoVideoEvents(videoRef, eventType, data) {
    if (!videoRef) return;
    try {
      const {
        processExpoVideoEvents
      } = require('../widgets/video/analytics/player-adapters/expoVideoPlayerAdapter');
      const handler = processExpoVideoEvents[eventType];
      if (handler) {
        handler(videoRef, data);
      }
    } catch (error) {
      // Silently fail if analytics adapter is not available
    }
  }
  processStatusUpdate(videoRef, status) {
    // For expo-video, status updates are handled directly in the event handlers
    this.processExpoVideoEvents(videoRef, 'onPlaybackStatusUpdate', status);
  }
  async getAnalyticsAdapter() {
    try {
      const {
        expoVideoPlayerAdapter
      } = await Promise.resolve().then(() => _interopRequireWildcard(require('../widgets/video/analytics/player-adapters/expoVideoPlayerAdapter')));
      return expoVideoPlayerAdapter;
    } catch (error) {
      return null;
    }
  }
}
exports.ExpoVideoAdapter = ExpoVideoAdapter;
//# sourceMappingURL=ExpoVideoAdapter.js.map