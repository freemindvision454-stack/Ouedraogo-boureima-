import React, { Component } from 'react';
import { SDKAnalyticsConstants } from './internal/SDKAnalyticsConstants';
import { VideoPlayerFactory } from './adapters';
class AdvancedVideo extends Component {
  constructor(props) {
    super(props);
    this.videoRef = /*#__PURE__*/React.createRef();
    const videoAdapter = VideoPlayerFactory.getAvailableAdapter();
    this.state = {
      analyticsConnector: null,
      previousStatus: undefined,
      analyticsInitialized: false,
      videoAdapter
    };
  }
  async componentDidMount() {
    setTimeout(() => {
      if (this.props.enableAnalytics && this.videoRef.current) {
        this.initializeAnalytics();
      }
    }, 100);
  }
  componentDidUpdate(prevProps) {
    if (this.props.enableAnalytics && !prevProps.enableAnalytics && this.videoRef.current && !this.state.analyticsInitialized) {
      this.initializeAnalytics();
    }
  }
  componentWillUnmount() {
    if (this.state.analyticsConnector && this.state.analyticsConnector.stopManualTracking) {
      this.state.analyticsConnector.stopManualTracking();
    }
  }
  getVideoUri = () => {
    if (this.props.videoUrl) {
      return this.props.videoUrl;
    }
    if (this.props.cldVideo) {
      return this.props.cldVideo.toURL({
        trackedAnalytics: SDKAnalyticsConstants
      });
    }
    return '';
  };
  initializeAnalytics = async () => {
    if (!this.props.enableAnalytics || !this.videoRef.current || this.state.analyticsInitialized) {
      return;
    }
    try {
      const {
        connectCloudinaryAnalytics
      } = await import('./widgets/video/analytics/cloudinary-analytics-react-native');
      const videoUri = this.getVideoUri();
      if (this.videoRef.current) {
        if (!this.videoRef.current._currentStatus) {
          this.videoRef.current._currentStatus = {};
        }
        this.videoRef.current._currentStatus.uri = videoUri;
      }
      const connector = connectCloudinaryAnalytics(this.videoRef.current);
      if (this.props.autoTrackAnalytics) {
        connector.startAutoTracking(this.props.analyticsOptions || {});
      }
      this.setState({
        analyticsConnector: connector,
        analyticsInitialized: true
      });
    } catch (error) {
      // Silently fail if analytics initialization fails
    }
  };
  onPlaybackStatusUpdate = status => {
    var _this$props$onPlaybac, _this$props;
    if (this.props.enableAnalytics && this.videoRef.current && this.state.analyticsInitialized) {
      if (!this.videoRef.current._currentStatus) {
        this.videoRef.current._currentStatus = {};
      }
      this.videoRef.current._currentStatus = {
        ...status,
        uri: this.getVideoUri()
      };
      try {
        // Use the adapter's status processing if available
        if (this.state.videoAdapter.processStatusUpdate) {
          this.state.videoAdapter.processStatusUpdate(this.videoRef.current, status, this.state.previousStatus);
        }
        this.setState({
          previousStatus: status
        });
      } catch (error) {}
    }

    // Forward status updates to parent component
    (_this$props$onPlaybac = (_this$props = this.props).onPlaybackStatusUpdate) === null || _this$props$onPlaybac === void 0 || _this$props$onPlaybac.call(_this$props, status);
  };
  startAnalyticsTracking = (metadata, options) => {
    if (this.state.analyticsConnector) {
      try {
        this.state.analyticsConnector.startManualTracking(metadata, {
          ...this.props.analyticsOptions,
          ...options
        });
      } catch (error) {}
    }
  };
  stopAnalyticsTracking = () => {
    if (this.state.analyticsConnector) {
      try {
        this.state.analyticsConnector.stopManualTracking();
      } catch (error) {}
    }
  };
  startAutoAnalyticsTracking = options => {
    if (this.state.analyticsConnector) {
      try {
        this.state.analyticsConnector.startAutoTracking({
          ...this.props.analyticsOptions,
          ...options
        });
      } catch (error) {}
    }
  };
  addCustomEvent = (eventName, eventDetails = {}) => {
    if (!this.props.enableAnalytics) {
      return;
    }
    if (!this.state.analyticsInitialized) {
      return;
    }
    if (this.state.analyticsConnector && this.state.analyticsInitialized) {
      try {
        if (this.state.analyticsConnector.addCustomEvent) {
          this.state.analyticsConnector.addCustomEvent(eventName, eventDetails);
        }
      } catch (error) {}
    }
  };

  // Playback control methods
  playAsync = async () => {
    if (this.videoRef.current) {
      try {
        // expo-av uses setStatusAsync for playback control
        await this.videoRef.current.setStatusAsync({
          shouldPlay: true
        });
      } catch (error) {
        console.warn('Failed to play video:', error);
      }
    }
  };
  pauseAsync = async () => {
    if (this.videoRef.current) {
      try {
        // expo-av uses setStatusAsync for playback control
        await this.videoRef.current.setStatusAsync({
          shouldPlay: false
        });
      } catch (error) {
        console.warn('Failed to pause video:', error);
      }
    }
  };
  setIsMutedAsync = async isMuted => {
    if (this.videoRef.current) {
      try {
        // expo-av uses setStatusAsync for muting
        await this.videoRef.current.setStatusAsync({
          isMuted
        });
      } catch (error) {
        console.warn('Failed to set muted state:', error);
      }
    }
  };
  setPositionAsync = async positionMillis => {
    if (this.videoRef.current) {
      try {
        // expo-av uses setStatusAsync for seeking
        await this.videoRef.current.setStatusAsync({
          positionMillis
        });
      } catch (error) {
        console.warn('Failed to set position:', error);
      }
    }
  };
  setStatusAsync = async status => {
    if (this.videoRef.current) {
      try {
        // Forward to underlying video component
        await this.videoRef.current.setStatusAsync(status);
      } catch (error) {
        console.warn('Failed to set status:', error);
      }
    }
  };
  render() {
    const videoUri = this.getVideoUri();
    if (!videoUri) {
      return this.state.videoAdapter.renderVideo({
        videoUri: '',
        style: this.props.videoStyle
      }, this.videoRef);
    }
    try {
      const videoElement = this.state.videoAdapter.renderVideo({
        videoUri,
        style: this.props.videoStyle,
        useNativeControls: this.props.useNativeControls,
        onPlaybackStatusUpdate: this.onPlaybackStatusUpdate,
        onLoadStart: () => {},
        onLoad: () => {},
        onError: () => {}
      }, this.videoRef);
      return videoElement;
    } catch (error) {
      // If the adapter fails, fall back to a fallback adapter
      const {
        FallbackVideoAdapter
      } = require('./adapters/FallbackVideoAdapter');
      const fallbackAdapter = new FallbackVideoAdapter(error instanceof Error ? `Video Error: ${error.message}` : 'Unknown video error');
      return fallbackAdapter.renderVideo({
        videoUri,
        style: this.props.videoStyle
      }, this.videoRef);
    }
  }
}
export default AdvancedVideo;
//# sourceMappingURL=AdvancedVideo.js.map