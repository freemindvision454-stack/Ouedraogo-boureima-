import { getVideoUrl } from '../utils';
export class VideoQualityManager {
  async handleQualityChange(qualityValue, videoRef, state, updateState, props) {
    updateState({
      currentQuality: qualityValue
    });
    if (qualityValue === 'auto') {
      const originalUrl = getVideoUrl(props.videoUrl, props.cldVideo);
      if (videoRef.current) {
        try {
          var _state$status, _state$status2;
          await videoRef.current.setStatusAsync({
            uri: originalUrl,
            shouldPlay: ((_state$status = state.status) === null || _state$status === void 0 ? void 0 : _state$status.shouldPlay) || false,
            positionMillis: ((_state$status2 = state.status) === null || _state$status2 === void 0 ? void 0 : _state$status2.positionMillis) || 0
          });
        } catch (error) {
          console.warn('Failed to switch to auto quality:', error);
        }
      }
      return;
    }
    const selectedQuality = state.availableQualityLevels.find(level => level.value === qualityValue);
    if (selectedQuality !== null && selectedQuality !== void 0 && selectedQuality.url && videoRef.current) {
      try {
        var _state$status3, _state$status4;
        await videoRef.current.setStatusAsync({
          uri: selectedQuality.url,
          shouldPlay: ((_state$status3 = state.status) === null || _state$status3 === void 0 ? void 0 : _state$status3.shouldPlay) || false,
          positionMillis: ((_state$status4 = state.status) === null || _state$status4 === void 0 ? void 0 : _state$status4.positionMillis) || 0
        });
      } catch (error) {
        console.warn('Failed to switch to quality level:', qualityValue, error);
      }
    } else {
      console.warn('No URL found for quality level:', qualityValue);
    }
  }
  handleToggleQualityMenu(isVisible, updateState) {
    updateState({
      isQualityMenuVisible: !isVisible
    });
  }
}
//# sourceMappingURL=videoQualityManager.js.map