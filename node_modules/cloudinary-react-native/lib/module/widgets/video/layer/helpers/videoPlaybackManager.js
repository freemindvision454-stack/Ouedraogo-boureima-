import { PanResponder } from 'react-native';
export class VideoPlaybackManager {
  createPanResponder(getCurrentState, updateState, clearAutoHideTimer, startAutoHideTimer, videoRef, seekbarRef) {
    return PanResponder.create({
      onStartShouldSetPanResponder: () => true,
      onMoveShouldSetPanResponder: () => true,
      onPanResponderGrant: _evt => {
        updateState({
          isSeeking: true
        });
        clearAutoHideTimer();
      },
      onPanResponderMove: evt => {
        const state = getCurrentState();
        if (seekbarRef.current && state.status) {
          const touchPageX = evt.nativeEvent.pageX;
          seekbarRef.current.measure((_x, _y, width, _height, pageX, _pageY) => {
            var _state$status;
            const touchX = touchPageX - pageX;
            const progress = Math.max(0, Math.min(1, touchX / width));
            const seekPosition = progress * (((_state$status = state.status) === null || _state$status === void 0 ? void 0 : _state$status.durationMillis) || 0);
            updateState({
              seekingPosition: seekPosition
            });
          });
        }
      },
      onPanResponderRelease: evt => {
        const state = getCurrentState();
        if (seekbarRef.current && state.status) {
          const touchPageX = evt.nativeEvent.pageX;
          seekbarRef.current.measure((_x, _y, width, _height, pageX, _pageY) => {
            var _state$status2;
            const touchX = touchPageX - pageX;
            const progress = Math.max(0, Math.min(1, touchX / width));
            const duration = ((_state$status2 = state.status) === null || _state$status2 === void 0 ? void 0 : _state$status2.durationMillis) || 0;
            const seekPosition = progress * duration;
            if (videoRef.current && state.status && duration > 0) {
              const validSeekPosition = Math.max(0, Math.min(seekPosition, duration - 100));
              const currentPosition = state.status.positionMillis || 0;
              const positionDiff = Math.abs(validSeekPosition - currentPosition);
              if (positionDiff > 100) {
                if (state.status.isLoaded && state.status.durationMillis && state.status.durationMillis > 0 && validSeekPosition >= 0 && validSeekPosition < state.status.durationMillis) {
                  videoRef.current.setStatusAsync({
                    positionMillis: validSeekPosition
                  }).catch(error => {
                    console.warn('Seek failed:', error);
                    updateState({
                      isSeeking: false,
                      seekingPosition: 0,
                      lastSeekPosition: 0,
                      isSeekingComplete: false
                    });
                  });
                }
              }
              updateState({
                isSeeking: false,
                seekingPosition: validSeekPosition,
                lastSeekPosition: validSeekPosition,
                isSeekingComplete: true
              });
            } else {
              updateState({
                isSeeking: false,
                seekingPosition: 0,
                lastSeekPosition: 0,
                isSeekingComplete: false
              });
            }
          });
        }
        const currentState = getCurrentState();
        if (currentState.isControlsVisible) {
          startAutoHideTimer(() => updateState({
            isControlsVisible: false
          }));
        }
      }
    });
  }
  getProgress(state) {
    if (!state.status) return 0;
    const duration = state.status.durationMillis || 1;
    const currentVideoPosition = state.status.positionMillis || 0;
    if (state.isSeeking) {
      return state.seekingPosition / duration;
    }
    if (state.isSeekingComplete && state.lastSeekPosition > 0) {
      return state.lastSeekPosition / duration;
    }
    return currentVideoPosition / duration;
  }
  getCurrentPosition(state) {
    if (!state.status) return 0;
    const currentVideoPosition = state.status.positionMillis || 0;
    if (state.isSeeking) {
      return state.seekingPosition;
    }
    if (state.isSeekingComplete && state.lastSeekPosition > 0) {
      return state.lastSeekPosition;
    }
    return currentVideoPosition;
  }
  async handlePlayPause(videoRef, status) {
    if (videoRef.current) {
      try {
        if (status !== null && status !== void 0 && status.isPlaying) {
          await videoRef.current.setStatusAsync({
            shouldPlay: false
          });
        } else {
          await videoRef.current.setStatusAsync({
            shouldPlay: true
          });
        }
      } catch (error) {
        console.warn('Failed to toggle play/pause:', error);
      }
    }
  }
  async handleMuteToggle(videoRef, status) {
    if (videoRef.current && status) {
      try {
        await videoRef.current.setIsMutedAsync(!status.isMuted);
      } catch (error) {
        console.warn('Failed to toggle mute:', error);
      }
    }
  }
  async handlePlaybackSpeedChange(videoRef, speed, updateState) {
    if (videoRef.current) {
      try {
        await videoRef.current.setStatusAsync({
          rate: speed
        });
        updateState({
          currentPlaybackSpeed: speed
        });
      } catch (error) {
        console.warn('Failed to change playback speed:', error);
      }
    }
  }
  handleToggleSpeedMenu(isVisible, updateState) {
    updateState({
      isSpeedMenuVisible: !isVisible
    });
  }
}
//# sourceMappingURL=videoPlaybackManager.js.map