import { fetchSubtitleFile, findActiveSubtitle } from '../utils/subtitleUtils';
export class VideoSubtitlesManager {
  async handleSubtitleChange(languageCode, state, updateState) {
    updateState({
      currentSubtitle: languageCode,
      activeSubtitleText: null
    });
    if (languageCode === 'off') {
      updateState({
        subtitleCues: [],
        activeSubtitleText: null
      });
      return;
    }
    const selectedTrack = state.availableSubtitleTracks.find(track => track.code === languageCode);
    if (selectedTrack !== null && selectedTrack !== void 0 && selectedTrack.url) {
      try {
        const subtitleCues = await fetchSubtitleFile(selectedTrack.url);
        updateState({
          subtitleCues
        });
      } catch (error) {
        console.warn('Failed to load subtitle file:', error);
        updateState({
          subtitleCues: []
        });
      }
    } else {
      console.warn('No URL found for subtitle track:', languageCode);
      updateState({
        subtitleCues: []
      });
    }
  }
  handleToggleSubtitlesMenu(isVisible, updateState) {
    updateState({
      isSubtitlesMenuVisible: !isVisible
    });
  }
  updateActiveSubtitle(status, state, updateState) {
    const {
      subtitleCues,
      currentSubtitle
    } = state;
    if (currentSubtitle === 'off' || subtitleCues.length === 0 || !(status !== null && status !== void 0 && status.isLoaded)) {
      if (state.activeSubtitleText !== null) {
        updateState({
          activeSubtitleText: null
        });
      }
      return;
    }
    const currentTimeSeconds = (status.positionMillis || 0) / 1000;
    const activeSubtitle = findActiveSubtitle(subtitleCues, currentTimeSeconds);
    const newSubtitleText = (activeSubtitle === null || activeSubtitle === void 0 ? void 0 : activeSubtitle.text) || null;
    if (state.activeSubtitleText !== newSubtitleText) {
      updateState({
        activeSubtitleText: newSubtitleText
      });
    }
  }
}
//# sourceMappingURL=videoSubtitlesManager.js.map